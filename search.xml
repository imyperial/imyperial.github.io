<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[由类的动态加载和AOP到插件化思想]]></title>
    <url>%2F2018%2F07%2F25%2Fweb-plugin%2F</url>
    <content type="text"><![CDATA[孔子曰: 与善人居，如入芝兰之室，久而不闻其香，即与之化矣。 写在前面&emsp;&emsp;web应用的升级和改造一般都需要重启应用，作为线上的应用，重新部署不免会影响用户的使用，当然现在运维技术高速发展，已经可以实现灰度等平滑过渡方式，但总的来说还是通过重新部署的方式。&emsp;&emsp;以前接触jenkins的时候，觉得这个东西真的好用啊，持续集成，节约了我们大部分时间，后面发现jenkins优秀的不止那么一点点，它的另一个功能引起了我的注意，插件管理，通过插件功能，可以实现在线升级和安装新应用。&emsp;&emsp;所以我就想能不能实现一个类似的功能，通过基于远程web端的插件下载和更新，在不重启应用的情况下装载运行，并且提供相应的插件控制台，实现插件的输出展示等？当然可以，下面我们就来一起实现。 项目设计&emsp;&emsp;废话不多说，根据设想绘制项目体系结构图： &emsp;&emsp;考虑到web插件的适用性，设计为远程插件仓库，通过类似于maven的方式实现下载安装，并且项目集成的插件可以随时卸载、暂停与启用，所以，相应的UML类图可绘制： &emsp;&emsp;基本思路我们又了，下面我们就来开发它吧。 具体开发 下载安装&emsp;&emsp;我们把插件信息配置成json格式存在远程，类似于： 123456789101112&#123; &quot;configs&quot;: [ &#123; &quot;active&quot;: true, &quot;className&quot;: &quot;com.frank.plugin.ServerLogPlugin&quot;, &quot;id&quot;: &quot;1&quot;, &quot;jarRemoteUrl&quot;: &quot;file:D:/site/com-frank-log-plugin-0.0.1-SNAPSHOT.jar&quot;, &quot;name&quot;: &quot;参数日志打印&quot; &#125; ], &quot;name&quot;: &quot;插件仓库&quot;&#125; &emsp;&emsp;通过下载插件,在服务启动的情况下加载我们定义好的jar包插件，然后把类加载至jvm中，便于调用执行，这里涉及到类的动态加载，那什么是类动态加载呢？ &emsp;&emsp;动态加载指的是每个编写的java拓展名类文件都存储着需要执行的程序逻辑，这些java文件经过Java编译器编译成拓展名为class的文件，class文件中保存着Java代码经转换后的虚拟机指令，当需要使用某个类时，虚拟机将会加载它的class文件，并创建对应的class对象，将class文件加载到虚拟机的内存。 &emsp;&emsp;我们这里借用idea生成的类图结构看出URLClassLoader中存在一个URLClassPath类. &emsp;&emsp;通过这个类就可以找到要加载的字节码流，也就是说URLClassPath类负责找到要加载的字节码，再读取成字节流，最后通过defineClass()方法创建类的Class对象。 &emsp;&emsp;从URLClassLoader类的结构图可以看出其构造方法都有一个必须传递的参数URL[]，该参数的元素是代表字节码文件的路径,换句话说在创建URLClassLoader对象时必须要指定这个类加载器的到那个目录下找class文件，为了更加便捷的加载类，我们可以通过反射的方式调用其protected方法addURL来加载类。所以代码可以这样写： 123456789101112131415161718192021222324252627282930313233343536File jarFile = new File(getLocalJarFile(config));// 从远程下载plugin 文件至本地if (!jarFile.exists()) &#123; URL url = new URL(config.getJarRemoteUrl()); InputStream stream = url.openStream(); jarFile.getParentFile().mkdirs(); try &#123; Files.copy(stream, jarFile.toPath()); &#125; catch (Exception e) &#123; jarFile.deleteOnExit(); throw new RuntimeException(e); &#125; stream.close();&#125;// 将本地jar 文件加载至 classLoaderURLClassLoader loader = (URLClassLoader) getClass().getClassLoader();URL targetUrl = jarFile.toURI().toURL();boolean isLoader = false;for (URL url : loader.getURLs()) &#123; if (url.equals(targetUrl)) &#123; isLoader = true; break; &#125;&#125;if (!isLoader) &#123; Method add = URLClassLoader.class.getDeclaredMethod(&quot;addURL&quot;, new Class[] &#123; URL.class &#125;); add.setAccessible(true); add.invoke(loader, targetUrl);&#125;// 初始化 Plugin Advice 实例化Class&lt;?&gt; adviceClass = loader.loadClass(config.getClassName());if (!Advice.class.isAssignableFrom(adviceClass)) &#123; throw new RuntimeException( String.format(&quot;plugin 配置错误 %s非 %s的实现类 &quot;, config.getClassName(), Advice.class.getName()));&#125;adviceCache.put(adviceClass.getName(), (Advice) adviceClass.newInstance()); 插件启用 &emsp;&emsp;在下载安装阶段我们已经通过类的动态加载把插件类加载至jvm中，但是要实现对功能调用和切入，必须得使用AOP的方式。先来看看准备好的一个小插件： 1234567public class ServerLogPlugin implements MethodBeforeAdvice &#123; public void before(Method method, Object[] args, Object target) throws Throwable &#123; String result = String.format(&quot;%s.%s() 参数:%s&quot;, method.getDeclaringClass().getName(), method.getName(),Arrays.toString(args)); System.out.println(result); &#125;&#125; &emsp;&emsp;这里用到了AOP，什么是AOP呢？ &emsp;&emsp;AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。 &emsp;&emsp;插件类实现了MethodBeforeAdvice接口，这个接口是aop的接口Advice的继承，它是一种前置增强，定义我们的插件在所切入的方法之前执行，能够达到在service方法调用之前打印其传入参数。所以我们在启用插件的时候就是去开始aop的切入，具体的实现方法入下： 123456789&lt;!-- 接入系统aop配置 --&gt;&lt;!-- 插件工厂配置 --&gt; &lt;bean id=&quot;pluginFactory&quot; class=&quot;com.frank.plugin.DefaultPluginFactory&quot; /&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;pluginFactory&quot;&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* *.*(..))&quot; /&gt; &lt;aop:before method=&quot;doBefore&quot; pointcut-ref=&quot;point&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &emsp;&emsp;DefaultPluginFactory中的启用插件的方法实现: 123456789101112131415161718192021PluginConfig config = configs.get(pluginConfigId);Arrays.stream(applicationContext.getBeanDefinitionNames()) .map(applicationContext::getBean) .filter(o -&gt; o!=null).filter(o -&gt; (o instanceof Advised)) .filter(o -&gt; findAdvice(config.getClassName(), (Advised) o) ==null) .forEach(o -&gt; &#123; Advice advice; try &#123; advice = buildAdvice(config); ((Advised) o).addAdvice(advice); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;启用失败&quot;, e); &#125; &#125;);try &#123; config.setActive(true); storeConfigs();&#125; catch (IOException e) &#123; // TODO 需要回滚已添加的切面 throw new RuntimeException(&quot;启用失败&quot;, e);&#125; 停用、卸载&emsp;&emsp;停用和启用插件方法相反，只需移除相关插件类的切面通知即可。卸载判断是否被启用，如果启用则停用后再删除对应插件，代码比较简单，不做阐述。 最终效果&emsp;&emsp;本文实现的插件系统作为测试使用，功能模块比较简单，有很多不完善的地方，最后实现的功能入下： 写在后面&emsp;&emsp;经过本次实践，进一步加深了对类的加载和aop的理解，后面了解到，插件这种类似的功能在安卓开发上有应用，安卓中通过动态代理的方式Hook系统服务,实现各种特定的功能，当然它的做法和实现复杂的多，但是我想他也离不开动态加载等。&emsp;&emsp;最后关于这web插件的扩展，其实有很多种方式，可以做成平台，也可以在自己公司搭建通用化组件,附上设想的插件体系业务架构：]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于开始写博客了]]></title>
    <url>%2F2018%2F05%2F12%2Fanthology-20180512%2F</url>
    <content type="text"><![CDATA[曾国藩有一句至理名言：“不为圣贤，便为禽兽；莫问收获，但问耕耘” 初衷&emsp;&emsp;其实我一直很懒，也不是一个感性的人，所以并没有写点东西的习惯，这点让我过得没心没肺，但是很多个夜晚，我都被这种空白感所恐惧，随着年龄的增长，这种恐惧的感觉出现的频次越来越高，后来我发现那是一种焦虑，一种对于现实皮囊下的不真实的慌张。 &emsp;&emsp; 时间需要去记录，思想需要去记录，学习需要去记录，成长需要去纪录…… 变迁&emsp;&emsp;以前的种种没有留下什么正式记录，只有年少的QQ空间，朋友圈或者微博留下过只言片语，其实现在想想挺有意思的，以前不管发生什么事，都需要发个说说之类的，虽然现在看起来有些内容显得很傻，但那又岂不是一份宝贵的成长记忆？所以花点时间把那些只言片语整理出来，做个归档，那也挺有意思的。 &emsp;&emsp;现在很少发朋友圈了，原因可能是花在社交网络的时间变少了，又或者是圈子里的人都长大了，有了更加核心的圈子，不会把什么都放在社交网络上，更加注重个人情感。我曾经看过好几个人都是那种宁愿建立一个没有任何人认识的微博小号，每天自己的写一些自己的事，这应该他们最真实的自己，而社交朋友圈和现实中则是换着不同的面具。 &emsp;&emsp;后来做了程序员，半路出家的那种，才知道点滴记录是多么的重要。人的一生成长都在不间断的接触新的事物，都在不断的学习，只是学习的方式和强度不一样而已。姑且我认为要做一个合格的程序员，需要学习的相关知识只多不少，只繁不减，并且是一个持续作战的过程，幸好程序员圈子传承了很多优良的习惯，前有open source，后有blog、论坛、GitHub等，要不说程序员都是好人，单纯善良，无私奉献。 平凡之路&emsp;&emsp;不是说穷则思变嚒，我是真的穷啊，时不时脑袋里会去想些新奇的idea，关于新的金融方式，关于新的渠道与市场，关于一些奇奇怪怪的创业方案，以前也只是想想而已，没去推敲，没去记录，可能机会就悄悄的溜走了，所以，这些东西还是记录下来好点，万一下次某个行业的改变或者新的市场诞生就是出自于这些idea呢？ &emsp;&emsp; 批判精神是人类文明的重要标志之一。我觉得个人应该首先有正确和先进的思想，直白点来说就是应该树立正确的三观，当然思想和三观这些东西都是没有一个天然的界定和划分的，现实也是通过大部分人的思想去界定，但是谁又能说绝大部分又是对的呢？所以应当怀着批判性去看待，努力做个好人吧。 &emsp;&emsp; 以前的学习都是被动性的去学习，缺乏了学习中我觉得最重要的“灵性”，学习效率就很低，学习深度很浅，究其根本，我发现自己不自觉太追逐所谓的新技术，太过于追求于快速临摹，以至于对于知识架构了解的不够系统与深入。这就好比武学中的形和意，再好的武学架子，没有理解其意，也不能功力大成。所以接下来将会是一场平凡之路，没有过多的花架子，修炼内功，追求武学真意。当然，我前面不是说了嚒，程序员都是善良和谦虚的，故而我会根据我自己的学习之路添加一些相关的blog，一方面用来记录自己的思考，一方面可供后学者参考。 写在最后&emsp;&emsp; 从毕业起就说写博客的，期间在博客园、CSDN、开发者头条、51CTO等都注册过账号，然而并没有写点什么，怪我这拖拖拉拉的性格。关于文字这块，真的有必要经常写，习惯了以前的社交朋友圈的小段文字，对于blog这种需要内容丰富点的方式，一下子还真适应不了，磕磕巴巴的花费了大约两个小时拼凑的这篇文章，不仅耗费了我许多精力，读起来还怪怪的，不过只能先这样了，相信以后写多了会越来越顺畅的。 &emsp;&emsp; 热血经常会有的，但要持续是件不容易的事，就好像以前我读高中的时候，每周回家过后，被父母说教一番，加之自我升华，好不容易攒着一大股子要好好学习的力气，在坐在去学校的公交车上，随着汽车的颠簸，随着窗外流动的世界，就被带走了一大半，到学校就连那仅剩的一点力气也无关痛痒了。所以，写博客，高质量的技术博客这件事，目标一个月一篇吧！]]></content>
      <categories>
        <category>杂集</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
